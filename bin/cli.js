#!/usr/bin/env node
'use strict';

var commander = require('commander');
var fs = require('fs');
var path = require('path');
var client = require('@notionhq/client');
var _ = require('lodash');
var prettier = require('prettier');
var dotenv = require('dotenv');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var commander__default = /*#__PURE__*/_interopDefaultLegacy(commander);
var fs__namespace = /*#__PURE__*/_interopNamespace(fs);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var ___default = /*#__PURE__*/_interopDefaultLegacy(_);
var prettier__default = /*#__PURE__*/_interopDefaultLegacy(prettier);
var dotenv__namespace = /*#__PURE__*/_interopNamespace(dotenv);

function parseJSONFile(path) {
  let rawdata = fs__namespace.readFileSync(path).toString();
  let data = JSON.parse(rawdata);
  return data;
}

function readNosimcliConfig(filepath) {
  return parseJSONFile(filepath);
}

var name = "nosimcli";
var version = "0.0.3";

class NotionClient {
  constructor(notionToken) {
    console.log(`Creating Notion client with token ${notionToken}`);
    this.notion = new client.Client({
      auth: notionToken
    });
  }
  getCollection = async databaseId => {
    console.log(`Retrieving collection ${databaseId}`);
    const response = await this.notion.databases.retrieve({
      database_id: databaseId
    });
    return response;
  };
  getCollectionPages = async (databaseId, query) => {
    const response = await this.notion.databases.query({
      database_id: databaseId,
      ...query
    });
    return response;
  };
  getPage = async () => {
    throw Error(`undefined method`);
  };
  getPageChildren = async () => {
    throw Error(`undefined method`);
  };
  getBlock = async () => {
    throw Error(`undefined method`);
  };
  getBlockChildren = async () => {
    throw Error(`undefined method`);
  };
}

class TextStyle {
  constructor(annotations) {
    this.fontWeight = annotations.bold ? 'bold' : null;
    this.fontStyle = annotations.italic ? 'italic' : null;
    this.textDecoration = [annotations.strikethrough && 'line-through', annotations.underline && 'underline'].join(' ');
    if (annotations.color.includes('background')) {
      this.backgroundColor = annotations.color.replace('_background', '');
    } else {
      this.color = annotations.color;
    }
    this.code = annotations.code;
  }
}
class RichText {
  constructor(richTextArray) {
    this.plainText = richTextArray.map(e => e.plain_text).join('');
    this.richText = richTextArray.map(e => new Text(e));
  }
}
class Text {
  constructor(richText) {
    this.text = richText.plain_text;
    this.href = richText.href;
    this.style = new TextStyle(richText.annotations);
  }
}

console.log(`__filename`, __filename);
console.log(`__dirname`, __dirname);
console.log(`process.cwd()`, process.cwd());
const DIR_CLASSES = path__default["default"].join(__dirname, '../src/notion/class');
const CONSTRUCTOR = `
  constructor(pageObject: PageObjectResponse | PartialPageObjectResponse) {
    super(pageObject);
  }
`;
const WARNING = `
  // This file was autogenerated by notion-simple-cli
  // don't edit below this line\n`;
const BASE_IMPORT_STATEMENTS = fs__default["default"].readFileSync(`${DIR_CLASSES}/base-imports.ts`);
const TYPE_MAP = {
  created_time: 'Date',
  last_edited_time: 'Date',
  date: 'Date',
  rich_text: 'RichText',
  title: 'RichText',
  number: 'number',
  select: 'Select',
  multi_select: 'Array<Select>',
  checkbox: 'boolean'
};

/**
 * Given the properties of a collection, it maps their types to a
 * Typescript type string definition.
 * @param property Property
 * @returns string
 */
function mapCollectionProperties(propertyConfig) {
  return ___default["default"].join(___default["default"].map(propertyConfig, property => `${___default["default"].camelCase(property.name)}: ${TYPE_MAP[property.type]};`), '\n');
}
class Collection {
  constructor(colObj) {
    this.id = colObj.id;
    this.createdTime = new Date(colObj.created_time);
    this.lastEditedTime = new Date(colObj.last_edited_time);
    this.url = colObj.url;
    this.title = new RichText(colObj.title);
    this.description = new RichText(colObj.description);
    this.properties = colObj.properties;
  }
  getClassName = (name = '', prefix = '') => {
    let className = name !== '' ? name : this.title.plainText;
    return ___default["default"].upperFirst(prefix) + ___default["default"].upperFirst(___default["default"].camelCase(className));
  };
  getFileName = (name = '', prefix = '') => {
    return ___default["default"].kebabCase(this.getClassName(name, prefix)) + '.ts';
  };
  genClassFileString = (name = '', prefix = '') => {
    let className = this.getClassName(name, prefix);
    let classDefinition = `
    ${WARNING}
    ${BASE_IMPORT_STATEMENTS}
    export class ${className} extends BaseCollectionPage {
      ${mapCollectionProperties(this.properties)}

      ${CONSTRUCTOR}
    };`;
    classDefinition = prettier__default["default"].format(classDefinition, {
      parser: 'typescript'
    });
    return classDefinition;
  };
}

const saveFile = async (content, filepath, filename) => {
  const fullPath = path__default["default"].join(__dirname, filepath, filename);
  console.log(`Saving file to ${fullPath} `);
  fs__default["default"].writeFileSync(fullPath, content);
};
const genClassFilesForConfig = async (config, output) => {
  const secret = process.env.NOTION_SECRET;
  if (!secret) throw Error('Notion secret is not defined');
  const notion = new NotionClient(secret);
  for (let database of config.databases) {
    let notionCollection = await notion.getCollection(database.id);
    let collection = new Collection(notionCollection);
    console.log(`processing database `, database);
    const [content, fileName] = [collection.genClassFileString(database.name, database.prefix), collection.getFileName(database.name, database.prefix)];
    if (!fs__default["default"].existsSync(path__default["default"].join(__dirname, output))) {
      fs__default["default"].mkdirSync(path__default["default"].join(__dirname, output), {
        recursive: true
      });
    }
    saveFile(content, output, fileName);
    fs__default["default"].readdirSync(path__default["default"].join(__dirname, '../src/notion/class')).forEach(e => {
      console.log(`copying file ${path__default["default"].join(__dirname, '../src/notion/class', e)} to ${path__default["default"].join(output, e)}`);
      fs__default["default"].copyFileSync(path__default["default"].join(__dirname, '../src/notion/class', e), path__default["default"].join(__dirname, output, e));
    });
  }
};

dotenv__namespace.config();
const CONFIG_FILE_LOCATION = './nosimcli.config.json';
const DEFAULT_FILEPATH = '.';
const program = new commander__default["default"].Command();
program.enablePositionalOptions().option('-d, --debug', 'output extra debugging');
program.command('generate').option('-c, --config <path>', 'config file (json)').option('-o, --output <path>', 'output file').option('-d, --debug', 'output extra debugging').action(options => {
  `reading config file from ${options.config ?? CONFIG_FILE_LOCATION}`;
  const config = readNosimcliConfig(options.config ?? CONFIG_FILE_LOCATION);
  options.debug && console.log(config);
  genClassFilesForConfig(config, options.output ?? DEFAULT_FILEPATH);
});
program.name(name);
program.version(version);
program.parse();
console.log(`calling from ${process.cwd()}`);
